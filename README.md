# kth-path-algorithms
Репозиторий с реализацией некоторых алгоритмов, которые умеют находить $k$-й кратчайший путь во взвешенном орграфе $G$.
Каждая реализация подразумевает, что:

- граф $G$ задается в нулевой индексации;
- стартовой вершиной считается вершина с номером $0$;
- конечной вершиной считается вершина с номером $n - 1$;
- веса ребер графа $G$ являются целыми неотрицательными числами (неотрицательность связана с тем, что так или иначе каждый алгоритм опирается на алгоритм Дейкстры);
- длина самого длинного найденного пути (в зависимости от алгоритма, эти пути могут быть разными) не превышает $2^64 - 1$ (как следствие, этим же числом ограничены веса ребер).

Кроме того, при оценке алгоритмов подразумевалось, что количество вершин $n \le$ количество ребер  $m$.
____
## Алгоритм Йены
Алгоритм Йены находит список $k$ кратчайших простых путей в графе.
Ограничения на граф будут следующими:

- $G$ не должен содержать ребер отрицательного веса (ввиду использования алгоритма Дейкстры для реализации алгоритма Йены);
- $G$ не должен содержать петель и кратных ребер (ввиду специфики самого алгоритма Йены);


### yens_algorithm.cpp
Программа является реализацией алгоритма Йены в виде функции 
```c++ 
vector<pair<unsigned long long, vector<int>>> yens_algorithm
(
    const vector<vector<pair<int, unsigned long long>>> &g_vector, 
    size_t number_of_paths
)
```
___g_vector___ - список смежностей графа;
___number_of_paths___ - количество путей, которые нужно найти алгоритмом (другими словами, число k)

Функция возвращает список из $k$ пар (длина пути, порядок вершин в пути).

Если за $l$ обозначить количество ребер в самом длинном найденном пути (по количеству ребер), то представленная реализация будет работать за $O(kl(m \log m + n \log k))$.
____

## dijkstra.cpp