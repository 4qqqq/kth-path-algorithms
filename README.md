# kth-path-algorithms
Репозиторий представляет собой набор реализаций некоторых алгоритмов, которые умеют находить $k$-й кратчайший путь во взвешенном орграфе $G$.
__Каждая__ реализация подразумевает, что:

- граф $G$ задается в нулевой индексации;
- стартовой вершиной считается вершина с номером $0$;
- конечной вершиной считается вершина с номером $n - 1$;
- веса ребер графа $G$ являются целыми неотрицательными числами (неотрицательность связана с тем, что так или иначе каждый алгоритм опирается на алгоритм Дейкстры);
- длина самого длинного найденного пути (в зависимости от алгоритма, эти пути могут быть разными) не превышает $2^{64} - 1$ (как следствие, этим же числом ограничены веса ребер).

Кроме того, при оценке алгоритмов подразумевалось, что количество вершин $n \le$ количество ребер  $m$.

Репозиторий непосредственно связан с курсовой работой: TODO.
____
## Алгоритм Йены
Алгоритм Йены находит список $k$ кратчайших __простых__ путей в графе.
Ограничения на граф будут следующими:

- $G$ не должен содержать ребер отрицательного веса (ввиду использования алгоритма Дейкстры для реализации алгоритма Йены);
- $G$ не должен содержать петель и кратных ребер (ввиду специфики самого алгоритма Йены).


### yens_algorithm.cpp
Программа является реализацией алгоритма Йены в виде функции 
```c++ 
vector<pair<unsigned long long, vector<int>>> yens_algorithm
(
    const vector<vector<pair<int, unsigned long long>>> &g_vector, 
    size_t number_of_paths
)
```
где
___g_vector___ - список смежностей графа;

___number_of_paths___ - количество путей, которые нужно найти алгоритмом (другими словами, число k)

Сама же функция возвращает список из $k$ пар (длина пути; порядок вершин в пути).

Если за $l$ обозначить количество ребер в самом длинном найденном пути (по количеству ребер), то представленная реализация будет работать за $\mathcal{O}(kl(m \log m + n \log k))$ времени и за $\mathcal{O}(kl^2)$ памяти.
____

## Модифицированный алгоритм Дейкстры

Модифицированный алгоритм Дейкстры находит длину $k$-го __непростого__ пути в графе.
Ограничения на граф будут следующими:

- $G$ не должен содержать ребер отрицательного веса.

### dijkstra.cpp

Программа является реализацией модифицированного алгоритма Дейкстры в виде функции 
```c++ 
vector<unsigned long long> modified_dijksrta
(
    const vector<vector<pair<int, unsigned long long>>> &g_vector, 
    size_t number_of_paths
)
```
где
___g_vector___ - список смежностей графа;

___number_of_paths___ - количество путей, которые нужно найти алгоритмом (другими словами, число k)

Сама же функция возвращает $k$ чисел - вектор длин первых $k$ кратчайших путей (если $k$ путей не существует вообще, то возвращается вектор с размером, равным количеству путей).

Представленная здесь реализация работает за $\mathcal{O}(mk \log (nk) )$ времени и $\mathcal{O}(nk)$ памяти.
____
## Алгоритм Эппштейна (упрощенный)

Алгоритм Эппштейна находит длину $k$-го __непростого__ пути в графе.
Ограничения на граф будут следующими:

- $G$ не должен содержать ребер отрицательного веса.

### eppstein.cpp

Программа является реализацией модифицированного алгоритма Дейкстры в виде функции 
```c++ 
vector<unsigned long long> eppstein_algorithm
(
    const vector<vector<pair<int, unsigned long long>>> &g_vector, 
    size_t number_of_paths
)
```
где
___g_vector___ - список смежностей графа;

___number_of_paths___ - количество путей, которые нужно найти алгоритмом (другими словами, число k)

Сама же функция возвращает $k$ чисел - вектор длин первых $k$ кратчайших путей (если $k$ путей не существует вообще, то возвращается вектор с размером, равным количеству путей).

Представленная здесь реализация работает за $\mathcal{O}(m \log m + k \log k)$ времени и $\mathcal{O}(m)$ памяти.

Стоит отметить, что оригинальный алгоритм Эппштейна работает несколько быстрее асимптотически.